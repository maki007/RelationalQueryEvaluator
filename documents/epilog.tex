\chapter{Conclusions}

We described Bobox architecture and Bobolang language in Chapter~\ref{boboxarchitecture}. Chapter~\ref{relatedwork} contains theory used to implement the query transformer. Chapter Analysis~\ref{analysis} deals with description of used algorithms and important data structures used in the implemented tool. Final chapter~\ref{implementation} presents some implementation details of created program.

The aim of this thesis was to implement part of the SQL compiler. Created program reads input relational algebra which is optimized. We implemented very effective optimization of logical plan: pushing selections down the tree. Possible physical plans were enumerated using Selinger--Style Optimization method. In this phase, we replaced algebra operators with physical plan. We implemented two different algorithms for choosing the order of joins. Asymptotically slower algorithm based on dynamic programming is used for estimated order of joins on smaller amount of relations. 
A faster greedy algorithm, which can generate less optimal join tree is provided for larger amount of joined relations. While choosing order of joins, we assigned physical algorithms. Merging of the assignment of physical algorithms and choice of join order can result in faster physical plan, in case we do not have information about sizes of input relations. Physical plan is written to output in the Bobolang language. Implemented compiler provides possibility to write algebra tree and physical plan to language Dot for debugging purposes.


Created software is a first part of planned SQL compiler. Front end, which transforms text query to the relational algebra, has not yet been implemented. At the time of submitting this thesis, compiler was successfully connected to Bobox. However, not all of the physical operators have been implemented. Therefore we were not able to evaluate any queries to prove that generated plans were correct.

We tested software by transforming some simple queries and queries from TPC benchmark TM H~\cite{benchmark} to physical plans. We are able to check generated plans by looking at generated debug outputs. Based on this results we conclude that generated plans are correct and optimal. 

Implemented tool can be improved by adding more logical plan optimizations.
After queries are run and their run time is measured, compiler time estimations, used for selection of physical algorithms, can be improved. 
We can also add support for more physical algorithms like nested loop joins.

