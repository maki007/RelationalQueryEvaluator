\chapter{Related work}
I the chapter we introduce some theory of relational algebra, it's optimizations and physical plan generation. This informations were used for tool implementation.
\section{Relational algebra}

In this chapter we introduce and describe relational algebra\cite{database}. We start with some basic definitions of relational model.

\begin{mydef}
$Relation$ is a two dimensional table.
\end{mydef}
\begin{mydef}
$Attribute$ is column of a table.
\end{mydef}
\begin{mydef}
$Schema$ name of the relations and a set of attributes. For example:~$Movie(id,name,lenght)$.
\end{mydef}
\begin{mydef}
$Tupple$ of a relation is a row other than header row.
\end{mydef}


An algebra in general consist of  operators and atomic operands. For example in arithmetic algebra variables like $x$ or constant like 15 and operators are addition multiplication, subtraction and division.
We can build expression by applying operators on operands or other expressions. Example of an expression in arithmetic algebra is $(15+x)*x$.

Relational algebra  has atomic operands:
\begin{itemize}
\item Variables, that are relations.
\item Constants, that are finite relations. 
\end{itemize}

In classical relational algebra all operates and expression results are set. All this operations can be applied also to bags.
Relation algebra operators are:
\begin{itemize}
\item Set operations - union, difference, intersection.
\item Removing operators - selection, which removes rows and projection that eliminates columns from given relation.
\item Operations that combine two relation, all kinds of joins.
\item Renaming operations, that doesn't change tuples of the relation bud changes schema.
\end{itemize}
Expressions in relational algebra are called $queries$.
\subsection{Classical relational algebra operators}
\subsubsection{Set operations on relations}

Sets operations are:
\begin{itemize}
\item Union $R\cap S$ is a set of tuples that are in $R$ or $S$.
\item Intersection $R\cup S$  is a set of tuples that are in both $R$ and $S$. 
\item Difference $R-S$ is a set of tuples that are in $R$ but not in $S$.

\end{itemize}

Lets have relations $R$ and $S$. If we want to apply some set operation both relations must have the same set of attributes. If we want to compute set theoretic union, difference or intersections the oder of columns must be the same in both relations. 
We can also use renaming operations if relations doesn't have same number of attributes.

\subsubsection{Projection}
\label{projection}
$Projection$ operator $\pi$ produces from relation R new Relations with reduced set of attributes. Result of a expression $\pi_{A_1,A_3,A_4,...,A_N}(R)$ is relation $R$ with attributes $A_1,A_3,A_4,...,A_N$. 

\subsubsection{Selection}
If we apply operator selection $\sigma$ on Relation $R$ with condition $C$ we get a new relation with same attributes and tuples, which satisfy given condition. For example $\sigma_{A_1=4}(R)$.

\subsubsection{Cartesian product}
Cartesian product of two sets $R$ and $S$ creates a set of pairs by choosing the first element of pair to be any element from R and second element of pair to be any element of S. Cartesian product of relations similar. We pair tuples from $R$ with all tuples from $S$.

\subsubsection{Natural joins}
We usually don't want to pair all of the tuples from $R$ to all tuples from $S$. We can par tuple in some other way. The simples join is called natural join of $R$ and $S$ ($R \Join S$). Let schema of $R$ be $R(r_1,r_2,..,r_n,c_1,c_2,...c_n)$ and schema of $S$ be  $S(s_1,s_2,..,s_n,c_1,c_2,...c_n)$. In natural join we pair tuple $r$ from relation $R$ to tuple $s$ from relation $S$ only if $r$ and $s$ agree on all attributes with same name (in this case $c_1,c_2,...c_n$).

\subsubsection{Theta joins}
Natural join forces us to use one specific condition. In may cases we want to join relation with some other condition. For this purpose we have theta-join. The notation for joining relation $R$ and $S$ based on condition $C$ is $R\Join_C S$. The result is constructed in following way:

\begin{enumerate}
\item Make Cartesian product of $R$ and $S$
\item Use selection with condition $C$.
\end{enumerate}

Basically $R\Join_C S=\sigma_C(R \times S)$

\subsubsection{Renaming}

In order to control name of attributes or relation name we have renaming operator. We can use operator $\rho_{S(A_1,A_2,...,A_n)}(R)$. Result will have the same tuples as $R$ but relation will be called S and attributes will be renamed to $(A_1,A_2,...,A_n)$.

\subsection{Relational operations on bags}

Commercial database system almost never are based purely on bags. $Bag$ is a multi-set. Only operation that behave differently are intersection union and difference. 

\subsubsection{Union}
Bag union of $R \cup S$ we just add all tuples from $S$ and $R$ together. If tuple $t$ appears in $R$ $m$-times and in $S$ $n$-times then in  $R \cup S$ will $t$ appear $m+n$ time. Both $m$ and $n$ can be zero.

\subsubsection{Intersection}

Lets have tuple $t$ that appears in $R$ $m$-times and $S$ $n$-times. In the Bag intersection $R \cap S$ will be $t$ $min(m,n)$-times.

\subsubsection{Difference}
Every tuple $t$ that appears in $R$ $m$-times and $S$ $n$-times, will appear $max(0,m-n)$ times in bag $R-S$.


\subsection{Extended operators of Relational algebra}

We will introduce extended operators that proved useful in many query languages like SQL.


\subsubsection{Duplicate elimination}
This operator $\delta(R)$ returns set consisting of one copy of every tuple that appears in bag R one or more times.

\subsubsection{Aggregate operations}

Aggregate operators such as sum are not relational algebra operator but are used  by grouping operator. They apply on column and produce one number as result. The standard operators are $SUM$, $AVG$(average), $MIN$, $MAX$ and $COUNT$.


\subsubsection{Grouping operator}

We often doesn't want to compute aggregation function for entire column. We rather compute this function on for some group of columns. For example we can compute average salary for every person in database, or we can group them by companies and get every salary in every company. 

For this purpose we have grouping operator $\gamma_L(R)$. $L$ is a list of:

\begin{enumerate}
\item Attribute of $R$ by which $R$ will be grouped.
\item Aggregation operator applied on a attribute of relation.
\end{enumerate}

Relation computed by expression $\gamma_L(R)$ is constructed:

\begin{enumerate}
\item Relation will be partitioned into groups. Every group contains all tuples which have same value in all grouping attributes. If there is no grouping attributes, all tuples will be in one group.
\item For each group operator produces one tuple consisting of:
 \begin{enumerate}
 	\item Grouping attributes values for group.
 	\item Results of aggregations over all tuple of processed group.
 \end{enumerate}
\end{enumerate}

Duplicate elimination operator is a special case of grouping operator. We can express $\delta(R)$ with $\gamma_{L}(R)$, where $L$ is a list of all attributes of $R$.

\subsubsection{Extended projection operator}

We can extend classical projection operator $\pi_L(R)$ introduced in chapter \ref{projection}. We denote it also $\pi_L(R)$ but projection list can have following elements:

\begin{enumerate}
\item Attribute of R, which means attribute will appear in output.
\item Expression $x = y$, attribute $y$ will be renamed to $x$.
\item Expression $x = E$, where $E$ is an expression created from attributes from R, constants, arithmetic, string  and other operators. $x$ is new name. For example $x=e*(1-l)$.
\end{enumerate}



\subsubsection{The sorting operator}

In several situations we want the output of query to be sorted. Expression $\tau_L(R)$, where $R$ is relation, $L$ is list of attributes with additional information about sort order, is relation with same tuples like $R$ but different order of tuples. Example:  $\tau_{A_1:A,A_2:D}(R)$ will sort relation $R$ by attribute $A_1$ ascending and tuples with same $A_1$ value will be additionally sorted by their $A_2$ value descending. 

\subsubsection{Outer joins}
Lets have join $R\Join_C S$. We call tuple $t$ from relation $R$ or $S$ $dangling$ if
we didn't find any match in relation $S$ or $R$. Outer join $R\Join^\circ_C S$ is formed by creating $R\Join_C S$ and adding dangling tuples from $R$ and $S$. The added tuples must be filled with special $null$ value in all attributes they don't have but appear in join result.

Left/right outer join is outer join but we only add dangling tuples from left/right relation.

\section{Optimizations of relational algebra}

After initial logical query plan is generated, we can apply some heuristics to improve it, using some algebraic laws that hold for relational algebra. 


\subsection{Commutative and associative laws}
Commutative and associative operators are Cartesian product, natural join, union and intersection. Theta join is commutative but generally is not associative. But if the conditions makes sense where they where positioned, then theta join is associative.
That means we can make following changes to algebra tree:

\begin{itemize}
\item $R \oplus S = S \oplus R$

\item $(R \oplus S) \oplus T = R \oplus (S \oplus T)$
\end{itemize}
$\oplus$ stands for $\times$, $\cap$, $\cup$, $\Join$ or $\Join_C$.

\subsection{Laws involving selection}

Selection are very important for improving logical plan. They usually reduce size of relation markedly so that's why we need to move them down the tree as far as possible.
We can change order of selections:

\begin{itemize}
\item $\sigma_{C_1}(\sigma_C{_2}(R)) = \sigma_C{_2}(\sigma_C{_1}(R))$
\end{itemize}
Sometimes we cannot push whole condition but we can split it:

\begin{itemize}
\item $\sigma_{C_1~AND~C_2}(R)=\sigma_{C_1}(\sigma_{C_2}(R))$

\item $\sigma_{C_1~OR~C_2}(R)=\sigma_{C_1}(R) \cup_S \sigma_{C_2}(R)$
\end{itemize}
Last law works only when $R$ is a set. $\cup_S$ stands for set union. We can push selection down union, it has to be pushed to both branches:
\begin{itemize}
\item $\sigma_{C}(R \cup S)=\sigma_{C}(R) \cup \sigma_{C}(S)$
\end{itemize}

When pushing selection through difference we must push it to first branch. Pushing to second branch optional. Laws for difference: 
\begin{itemize}
\item $\sigma_{C}(R-S)=\sigma_{C}(R) - \sigma_{C}(S)$
\item $\sigma_{C}(R-S)=\sigma_{C}(R) - S$
\end{itemize}

Following laws allow to push selection down both arguments. Let's have selection $\sigma_C$. We can push it to the branch, which contains all attributes used in $C$. If $C$ contains only attributes of $R$:
\begin{itemize}
\item $\sigma_{C}(R \oplus S)=\sigma_{C}(R) \oplus S$
\end{itemize}
$\oplus$ stands for $\times$, $\cap$, $\cup$, $\Join$ or $\Join_C$. If relation $S$ and $R$ contains all attributes of $C$ we can also use following law:
\begin{itemize}
\item $\sigma_{C}(R \Join S)=\sigma_{C}(R) \Join  \sigma_{C}(S)$
\end{itemize}


\subsection{Laws involving projection}
Principle for manipulation with projections that we can add projection anywhere in the tree as long as it only eliminates attributes which are not used anymore and don't appear in query result.
\subsection{Laws involving joins and products}

We have more laws involving selection that follow directly from definition of the join:
\begin{itemize}
\item $\sigma_{C}(R \times S)=R \Join_{C} S$
\item $R \Join S=\pi_L(\sigma_{C}(R \times S))$, $C$ is condition that equates each pair of attributes of $R$ and $S$, which have the same name and $L$ is a list of attributes of relation $R$.
\end{itemize}



\section{Physical plan generation}

After we optimized logical plan, we need to create physical plan. We generate many physical plans a choose one with least estimated cost to run it. This approach is called cost-based enumeration.

For each physical plan we select 
\begin{enumerate}
\item An order of grouping and joins.
\item An algorithm for each operator. For example if we use join based on hashing or sorting.
\item Additional operators which are not presented in logical plan. For example we can sort relation in order to user faster algorithm which assumes that it's input is sorted.
\item The way in which arguments are pass to between operators. We can use iterators for it or store result on hard drive.
\end{enumerate}

\subsection{Size estimations}

The costs of evaluating physical plan are based of estimated size of interme\-dia\-te relations. Ideally we want out estimation to be accurate, easy to compute and logically consistent(size of relation doesn't depend on how relation is computed). We will present simple rules, which will give us give us good estimations in most situation. Goal of estimating sizes is not predict exact size of relation, even an inaccurate sizes will help us with plan generation.

In this section we will use following conventions:

\begin{itemize}
\item $T(R)$ is number of tuples in relation R.
\item $V(R,a)$ number of distinct values in attribute $a$. 
\item $V(R,[a_1,a_2,...,a_n])$ is number of tuples in $\delta(\pi_{a_1,a_2,...,a_n}(R))$
\end{itemize}

\subsubsection{Estimating the size of projection}

Projection is only operator which size of result is compatible. It doesn't change number ot tuples, their lengths change.

\subsubsection{Estimating the size of selection}

Selection reduces number of tuples.Lets have $S=\sigma_{A=c}(R)$, where $A$ is a attribute of $R$ and $c$ is a constant. Recommended estimation is:
\begin{itemize}
\item $T(S)=T(R)/V(R,A)$
\end{itemize}

More problematic estimation is when selection involves inequality comparison Lets have $S=\sigma_{A<c}(R)$. In average half the tuple satisfies condition, but usually queries select only a small fraction from all tuples. Therefore the estimation is:
\begin{itemize}
\item $T(S)=T(R)/3$
\end{itemize}

For selection where condition is in form $C_1~and~C_2~and~...~and~C_N$ we can treat selection as a cascade of simple selections and estimate size for every simpler condition

When selection involves $not$ and we have $S=\sigma_{not(C)}(R)$ we can use following estimation:
\begin{itemize}
\item $T(S)=T(R)-T(\sigma_C(R))$
\end{itemize}

Little more complicated is when condition involved an $or$ of conditions. Lets have expression $S=\sigma_{C_1~or~C_2}(R)$. We can assume that $C_1$ and $C_2$ are independent. Size of $S$ is:

\begin{itemize}
\item $T(S)=T(R)(1-(1-\dfrac{m_1}{T(R)})(1-\dfrac{m_2}{T(R)}))$
\end{itemize}

Expression $1-\dfrac{m_1}{T(R)}$ is fraction of tuples which doesn't satisfy condition $C_1$ and $1-\dfrac{m_2}{T(R)}$ is fraction of tuples which doesn't satisfy condition $C_2$. Product of these numbers are the fraction of tuples from $R$ which are not in result. One minus the product gives us fraction of tuples in $S$.

\subsubsection{Estimating the size of join}

a

\subsubsection{Estimating the size of union}

\subsubsection{Estimating the size of intersection}

\subsubsection{Estimating the size of difference}

\subsubsection{Estimating the size of grouping}


\subsection{Enumerating plans}

\subsection{Choosing join order}

\subsection{Choosing physical algorithms}

table
select
join
